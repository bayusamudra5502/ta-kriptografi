\chapter{Implementasi dan Pengujian}

\section{Implementasi}

Bagian ini menjelaskan dari implementasi solusi yang telah dirancang sebelumnya. Bagian ini akan menjelaskan terkait lingkungan implementasi, batasan dari implementasi, serta implementasi tiap bagian dari protokol TLS.

\subsection{Batasan Implementasi}
Implementasi dilakukan dengan beberapa batasan dari protokol TLS yang telah didefinisikan pada \textcite{rfc5246}. Berikut ini merupakan batasan yang diterapkan:

\begin{enumerate}
  \item Implementasi hanya dilakukan menggunakan satdu \emph{cipher suite} saja, yaitu enkripsi menggunakan AES-256 berbasis sistem \emph{chaos}, pertukaran kunci ECDSA, algoritma hash SHA-256.
  \item Tiap pesan pada protokol \emph{handshake} dikirimkan melalui Protokol \emph{Record} yang berbeda.
  \item Fitur kompresi pada protokol TLS tidak diimplementasikan.
  \item Sertifikat digital diverifikasi secara \emph{pinning} dan tidak melakukan verifikasi \emph{revocation}.
  \item Sertifikat digital yang digunakan merupakan \emph{self-signed certificate} yang mendukung ECDSA untuk tanda tangan digital.
  \item Kurva eliptik yang didukung pada proses pertukaran kunci hanyalah kurva secp256r1.
\end{enumerate}
  
Pemilihan implementasi satu cipher ditujukan agar proses pengembangan dapat berfokus hanya pada \emph{cipher suite} yang hendak dikembangkan. Hal ini juga dapat membantu menyederhanakan pustaka yang dibangun sehingga proses pengembangan dapat lebih mudah dan cepat. 

Pemilihan pertukaran kunci berbasis ECDSA didasarkan pada kekuatan dari ECDSA. Menurut \textcite{munir2019}, ECDSA diyakini memiliki kekuatan yang setara dengan RSA walaupun dengan menggunakan kunci yang lebih pendek. Hal ini dapat membantu mengurangi \emph{resource} pada perangkat yang menggunakan pustaka ini.

Pengiriman pesan \emph{handshake} pada dasarnya dapat disatukan dalam sebuah protokol \emph{record}. Akan tetapi, pada implementasi pustaka ini, pesan \emph{handshake} dikirimkan terpisah dengan tujuan  membantu pada fase \emph{debugging} melalui aplikasi Wireshark dikarenakan tiap layer protokol \emph{record} akan ditampilkan secara terpisah.

Pada implementasi, fitur kompresi dinonaktifkan. Hal ini dikarenakan untuk melihat kualitas dari hasil enkripsi pada layer TLS. Kualitas yang dapat terlihat salah satunya terkait dengan hubungan antar blok serta keteracakan dari hasil enkripsi. Apabila plainteks dikomporesi, hasil enkripsi akan lebih mampat sehingga keteracakan akan sangat terlihat dan hilangnya hubungan antar blok.

Sertifikat digital yang digunakan pada implementasi ini merupakan sertifikat yang \emph{self-signed}. Fokus utama dari implementasi sertifikat digital hanya untuk memastikan bahwa MITM tidak terjadi. Oleh karena itu, implementasi berbentuk \emph{pinning} dan \emph{self-signed certificate} dinilai sudah cukup.

\subsection{Lingkungan Implementasi}

Lingkungan implementasi dari protokol TLS ditunjukan pada tabel \ref{tab:impl.env}.

\begin{table}[!h]
  \centering
  \caption{Lingkungan Implementasi} \label{tab:impl.env}
  \begin{tabular}{|p{3cm}|p{6cm}|}
    \hline
    Jenis Lingkungan & Nilai \\ \hline
    Sistem Operasi & Fedora Linux 40 \\ \hline
    Bahasa Pemrograman & Python 3.12.3 \\ \hline
    Kernel & Linux 6.8.9 \\ \hline
    Manager Paket & Pip 23.3.2 \\ \hline
  \end{tabular}
\end{table}

Pemilihan python sebagai bahasa pemrograman dikarenakan bahasa ini dapat mempermudah dalam proses pengujian dan pembentukan grafik. Selain itu, bahasa python memiliki pustaka cukup lengkap saat akan melakukan operasi matematika dan juga operasi kriptografi. Hal ini ditambah dengan hadirnya paket manager pip yang dapat menambah pustaka standar yang ada pada bahasa python.

Penggunaan Linux dalam lingkungan implementasi dikarenakan Linux memiliki fitur \emph{unix socket}. Hal ini dapat digunakan untuk melakukan simulasi jaringan melalui \emph{unit testing} sehingga tidak perlu membuka port untuk TCP. Hal ini dapat mencegah kegagalan akibat port TCP yang dipakai untuk \emph{unit testing} tidak bisa di-\emph{bind}.

Terdapat beberapa pustaka yang digunakan sebagai dependensi dari pustaka yang dibangun. Tabel \ref{tab:impl.lib} menyatakan daftar pustaka serta fungsi dari pustaka tersebut dalam pengembangan pustaka TLS berbasis sistem \emph{chaos}.

\begin{table}[!h]
  \centering
  \caption{Pustaka yang Digunakan} \label{tab:impl.lib}
  \begin{tabular}{|p{4cm}|p{9cm}|}
    \hline
    Nama Pustaka & Deskripsi \\ \hline
    \texttt{cryptography 42.0.5} & Pustaka ini digunakan untuk membantu dalam proses validasi tanda tangan digital dan \emph{parsing} sertifikat digital. Pustaka ini juga membantu dalam menghitung hasil Eliptic Curve Diffie-Hellman yang dilakukan pada saat \emph{Handshake} \\ \hline
    \texttt{pycryptodome 3.19.0} & Pustaka ini digunakan untuk membantu dalam melakukan proses enkripsi serta dekripsi pesan. Selain itu, pustaka ini juga membantu dalam menghitung operasi HMAC. \\ \hline
    \texttt{numpy 1.26.2} & Pustaka ini digunakan untuk membantu operasi pada array serta operasi \emph{floating-point}.\\ \hline
    \texttt{secrets} & Pustaka standard ini digunakan untuk melakukan \emph{secure comparation} dan membangkitkan nilai CSPRNG yang berasal dari sistem operasi. \\ \hline
    \texttt{socket} & Pustaka standard ini digunakan untuk melakukan komunikasi menggunakan protokol TCP.\\ \hline
  \end{tabular}
\end{table}


\subsection{Implementasi Modul Utilitas dan Kriptografi}

Dalam pengembangan pustaka, terdapat utilitas yang dapat membantu dalam proses pengembangan. Tabel \ref{tab:impl.util} menjelaskan terkait beberapa fungsi utilitas yang diimplementasikan pada pustaka yang dibangun.

\begin{table}[!h]
  \centering
  \caption{Fungsi pada Modul Utilitas} \label{tab:impl.util}
  \begin{tabular}{|p{2.5cm}|p{3.5cm}|p{8cm}|}
    \hline
    Modul & Nama Fungsi & Deskripsi \\ \hline
    \texttt{util} & \texttt{to\_linear(x)} & Fungsi ini ditujukan untuk melakukan proses linearisasi berdasarkan persamaan \ref{eq:chaos.linearization} \\ \hline
    \texttt{util} & \texttt{xor(x,y)} & Fungsi ini ditujukan untuk melakukan xor pada tiap-tiap bit yang ada pada nilai $x$ dan $y$ \\ \hline
    \texttt{util} & \texttt{to\_bytes\_big(x,y)} & Fungsi ini mengkonversi nilai $x$ dan $y$ dalam format \emph{big-endian} \\ \hline
    \texttt{util} & \texttt{to\_int\_big(x)} & Fungsi ini mengkonversi nilai bytes $x$ menjadi integer\\ \hline
    \texttt{crypto.sign} & \texttt{sign(data, pk)} & Fungsi ini akan membuat digital signature dengan berdasarkan kunci privat $pk$\\ \hline
    \texttt{crypto.sign} & \texttt{verify(data, sign, pk)} & Fungsi ini akan mengembalikan \texttt{true} apabila signature valid berdasarkan data dan kunci publik $pk$\\ \hline
    \texttt{crypto.key} & \texttt{generate\_shared} \texttt{\_secret(sp, cs)} & Fungsi ini akan menghasilkan \emph{premaster secret} yang diturunkan dari oprasi ECDSA menggunakan kunci publik $sp$ dan kunci privat $cs$\\ \hline
    \texttt{crypto.key} & \texttt{generate\_master} \texttt{\_secret(pms, r\_c, s\_r)} & Fungsi ini akan menghasilkan \emph{master secret} yang diturunkan berdasarkan \ref{eq:tls.master}\\ \hline
    \texttt{crypto.key} & \texttt{generate\_chaos} \texttt{\_parameter(ms, r\_c, s\_r)} & Fungsi ini akan menghasilkan objek AES dan HMAC melalui proses ekspansi kunci dan pembentukan sistem \emph{chaos}\\ \hline
  \end{tabular}
\end{table}

Selain utilitas umum, terdapat beberapa kelas yang diimplementasikan sebagai utilitas yang memfasilitasi operasi kriptografi dan pembangkitan kunci acak. Tabel \ref{tab:impl.util.crypto} menjelaskan beberapa kelas yang diimplementasikan pada pustaka yang dibangun.

\begin{table}[!h]
  \centering
  \caption{Kelas pada Modul Utilitas dan Crypto} \label{tab:impl.util.crypto}
  \begin{tabular}{|p{2.75cm}|p{3.5cm}|p{8cm}|}
    \hline
    Modul & Nama Kelas & Deskripsi \\ \hline
    \texttt{crypto.aes} & \texttt{DynamicState} & Kelas ini digunakan sebagai \emph{base class} dari HMAC dan AES \\ \hline
    \texttt{crypto.aes} & \texttt{DynamicAES} & Kelas ini digunakan untuk melakukan operasi enkripsi menggunakan AES\\ \hline
    \texttt{crypto.aes} & \texttt{DynamicHMAC} & Kelas ini digunakan untuk melakukan operasi HMAC\\ \hline
    \texttt{crypto.csprng} & \texttt{SineHenonMap} & Kelas ini digunakan untuk membantu dalam menghasilkan nilai \emph{chaos} sesuai persamaan \ref{eq:tls.chaos}.\\ \hline
  \end{tabular}
\end{table}

\subsection{Implementasi Modul Data}

Dalam pengembangan pustaka, terdapat beberapa kelas yang dibangun untuk membantu dalam menangani data. Kelas-kelas ini digunakan untuk membantu dalam proses \emph{parsing} dan \emph{encode} data. Tabel \ref{tab:impl.data} menjelaskan beberapa kelas yang diimplementasikan pada pustaka yang dibangun. Semua kelas pada bagian ini terletak pada modul \texttt{data}.

\begin{longtable}{|p{3.5cm}|p{9cm}|}
  \caption{Kelas pada Modul Data} \label{tab:impl.data} \\

  \hline
    Nama Kelas & Deskripsi \\ \hline
    \endhead

    \texttt{TLSPayload} & Kelas ini merupakan kelas abstrak yang merupakan induk dari semua kelas data yang merepresentasikan data pada \textcite{rfc5246}\\ \hline
    \texttt{TLSCertificate} & Kelas ini merepresentasikan tipe data \texttt{Certificate} pada \textcite{rfc5246} \\ \hline
    \texttt{ChangeCipherSpec} & Kelas ini merepresentasikan tipe data \texttt{ChangeCipherSpec} pada \textcite{rfc5246} \\ \hline
    \texttt{ProtocolVersion} & Kelas ini merepresentasikan tipe data \texttt{ProtocolVersion} pada \textcite{rfc5246} \\ \hline
    \texttt{ContentType} & Kelas ini merepresentasikan tipe data \texttt{ContentType} pada \textcite{rfc5246} \\ \hline
    \texttt{ContentType} & Kelas ini merepresentasikan enum dari content type yang ada pada \textcite{rfc5246} \\ \hline
    \texttt{Signature} & Kelas ini merupakan kelas yang merepresentasikan tipe data \texttt{Signature} pada \textcite{rfc5246}\\ \hline
    \texttt{ECPoint} & Kelas ini merupakan kelas yang merepresentasikan titik kurva eliptik seperti tipe data \texttt{ECPoint} pada \textcite{rfc4492}\\ \hline
    \texttt{ECParameter} & Kelas ini merupakan kelas yang merepresentasikan tipe data \texttt{ECParameter} pada \textcite{rfc4492}. Parameter ini digunakan untuk merepresentasikan tipe kurva saat proses ECDH.\\ \hline
    \texttt{ECDHParameter} & Kelas ini merupakan kelas yang merepresentasikan tipe data \texttt{ECDHParameter} pada \textcite{rfc4492}. Parameter ini digunakan untuk merepresentasikan titik saat proses ECDH.\\ \hline
    \texttt{KeyExchange} & Kelas ini merupakan kelas abstrak yang menyatakan representasi induk dari tipe data KeyExchange untuk Client dan Server.\\ \hline
    \texttt{ServerKeyExchange} & Kelas ini merupakan kelas yang menyatakan representasi data \texttt{ServerKeyExchange} pada \textcite{rfc5246}.\\ \hline
    \texttt{ClientKeyExchange} & Kelas ini merupakan kelas yang menyatakan representasi data \texttt{ClientKeyExchange} pada \textcite{rfc5246}.\\ \hline
    \texttt{Finish} & Kelas ini merupakan kelas yang menyatakan representasi data \texttt{Finished} pada \textcite{rfc5246}.\\ \hline
    \texttt{Handshake} & Kelas ini merupakan kelas yang menyatakan representasi data \texttt{Handshake} pada \textcite{rfc5246}.\\ \hline
    \texttt{Random} & Kelas ini merupakan kelas yang menyatakan representasi data \texttt{Random} pada \textcite{rfc5246}.\\ \hline
    \texttt{ClientHello} & Kelas ini merupakan kelas yang menyatakan representasi data \texttt{ClientHello} pada \textcite{rfc5246}.\\ \hline
    \texttt{ServerHello} & Kelas ini merupakan kelas yang menyatakan representasi data \texttt{ServerHello} pada \textcite{rfc5246}.\\ \hline
    \texttt{ServerHelloDone} & Kelas ini merupakan kelas yang menyatakan representasi data \texttt{ServerHelloDone} pada \textcite{rfc5246}.\\ \hline
    \texttt{TLSRecordLayer} & Kelas ini merupakan kelas yang menyatakan representasi data \texttt{TLSRecordLayer} pada \textcite{rfc5246}.\\ \hline
    \texttt{TLSCiphertext} & Kelas ini merupakan kelas yang menyatakan representasi data \texttt{TLSCiphertext} pada \textcite{rfc5246}.\\ \hline
\end{longtable}

Tabel \ref{tab:impl.enum} menjelaskan beberapa enum yang diimplementasikan pada pustaka yang dibangun. Enum ini berisi beberapa konstanta yang digunakan pada protokol TLS.

\begin{table}[!h]
  \centering
  \caption{Enum pada Modul Data} \label{tab:impl.enum}
  \begin{tabular}{|p{3.75cm}|p{9cm}|}
    \hline
    Nama Enum & Deskripsi \\ \hline
    \texttt{ContentType} & Enum ini mengenumerasi nilai \emph{content type} yang ada pada \textcite{rfc5246} \\ \hline
    \texttt{CipherSuite} & Enum ini mengenumerasi nilai enum dari \emph{cipher suite} yang diimplementasikan pada pustaka \\ \hline
    \texttt{CompressionMethod} & Enum ini mengenumerasi nilai enum dari metode kompresi yang diimplementasikan pada pustaka \\ \hline
    \texttt{HashAlgorithm} & Enum ini mengenumerasi nilai enum dari algoritma hash yang didukung pada pustaka \\ \hline
    \texttt{SignatureAlgorithm} & Enum ini mengenumerasi nilai enum dari algoritma tanda tangan digital yang didukung pada pustaka \\ \hline
    \texttt{ECCurveType} & Enum ini mengenumerasi nilai enum dari tipe \texttt{CurveType} yang didukung pada pustaka\\ \hline
    \texttt{NamedCurve} & Enum ini mengenumerasi nilai enum dari kurva eliptik yang didukung pada pustaka\\ \hline
    \texttt{HandshakeType} & Enum ini mengenumerasi nilai enum dari tipe handshake pada TLSv1.2\\ \hline
  \end{tabular}
\end{table}

Struktur data dari kelas yang telah dijelaskan di atas didefinisikan pada \textcite{rfc5246} dan \textcite{rfc4492}. Untuk mempermudah pengaksesan, penulis menyertakan tipe data tersebut pada Lampiran \ref{appendix:tls12.datatype}.

\subsection{Implementasi Modul Komunikasi}

Dalam pustaka yang dikembangkan, terdapat sebuah modul yang bertanggung jawab mengatur komunikasi antara \emph{client} dan \emph{server}. Modul ini bertanggung jawab dalam mengatur proses \emph{handshake}, proses komunikasi melalui TCP, komunikasi melalui UNIX Socket, serta proses enkripsi dan pengaturan \emph{state}. Tabel \ref{tab:impl.comm} menjelaskan beberapa kelas yang diimplementasikan pada pustaka yang dibangun. Semua kelas pada bagian ini terletak pada modul \texttt{conn}.

\begin{longtable}{|p{4cm}|p{8cm}|}
  \caption{Kelas pada Modul Komunikasi} \label{tab:impl.comm} \\

  \hline
    Nama Kelas & Deskripsi \\ \hline
    \endhead

    \texttt{TLSHandshake} & Kelas ini merupakan kelas abstrak yang bertanggung jawab dalam memberikan prototipe perilaku dari kelas yang menglakukan proses TLS \emph{Handshake}\\ \hline
    \texttt{ClientHandshake} & Kelas ini bertanggung jawab untuk melakukan proses handshake pada sisi klien\\ \hline
    \texttt{ServerHandshake} & Kelas ini bertanggung jawab untuk melakukan proses handshake pada sisi server\\ \hline
    \texttt{Transport} & Kelas ini merupakan kelas abstrak yang menggambarkan perilaku dari setiap kelas yang dapat menjadi transport layer\\ \hline
    \texttt{MemoryTransport} & Kelas ini merupakan yang mensimulasikan transport layer pada memori\\ \hline
    \texttt{Socket} & Kelas ini merupakan yang berperasn sebagai transport layer pada Unix Socket\\ \hline
    \texttt{SingleSocketServer} & Kelas ini merupakan kelas yang berperan sebagai \emph{UNIX Socket Server}\\ \hline
    \texttt{SocketClient} & Kelas ini merupakan kelas yang berperan sebagai \emph{UNIX Socket Client}\\ \hline
    \texttt{TCP} & Kelas ini merupakan kelas yang berperan sebagai transport layer pada TCP\\ \hline
    \texttt{TCPServer} & Kelas ini merupakan kelas yang berperan sebagai \emph{server manager} pada protokol TCP\\ \hline
    \texttt{TCPClient} & Kelas ini merupakan kelas yang berperan sebagai klien pada protokol TCP\\ \hline
    \texttt{TLSConnection} & Kelas ini merupakan kelas yang berperan dalam mengatur alur dari protokol TLS\\ \hline
    \texttt{TLSApplication} \texttt{RecordHandler} & Kelas ini merupakan kelas yang digunakan untuk mengatur \emph{application data} pada protokol TLS\\ \hline
\end{longtable}
  

\section{Pengujian}
Bagian ini menjelaskan dari pengujian yang dilakukan terhadap pustaka yang telah dibangun. Bagian ini akan menjelaskan terkait dengan detail pengujian yang dilakukan serta hasil dari pengujian tersebut.

\subsection{Tujuan Pengujian}
Pengujian dilakukan dengan tujuan sebagai berikut:
\begin{enumerate}
  \item Menguji fungsionalitas dan keamanan dari \emph{cipher} yang dibangun.
  \item Menguji fungsionalitas dan keamaman dari implementasi protokol TLS yang dibangun.
\end{enumerate}

Pengujian fungsionalitas \emph{cipher} dilakukan untuk memastikan bahwa \emph{cipher} yang dibangun dapat menjalankan proses kriptografi dengan baik. Pengujian ini dilakukan dengan melakukan operasi kriptografi pada \emph{cipher} yang telah dibangun sesuai dengan kasus yang didefinisikan. Pengujian keamanan pada \emph{cipher} dilakukan dengan melakukan uji statistik pada sistem \emph{chaos} dan \emph{cipher} yang dibangun. Hal ini bertujuan untuk mengetahui sifat statistik yang mungkin muncul pada sistem \emph{chaos} dan hasil enkripsi dari \emph{cipher} yang dibangun. Uji statistik dilakukan dengan menggunakan NIST Statistical Test Suite yang telah diimplementasikan oleh \textcite{marek2016}. Pengujian ini dilakukan untuk menguji jawaban atas rumusan masalah pertama.

Pengujian fungsionalitas protokol TLS dilakukan untuk memastikan bahwa protokol yang dibangun dapat berjalan dengan baik. Pengujian ini dilakukan dengan melakukan proses \emph{handshake} pada protokol TLS yang dibangun dan proses pengiriman pesan. Pengujian ini dilakukan secara \emph{end to end} testing. Pengujian keamanan protokol TLS dilakukan dengan menguji beberapa kasus serangan yang mungkin terjadi pada protokol TLS. Pengujian ini dilakukan untuk menguji jawaban atas rumusan masalah kedua.

\subsection{Lingkungan Pengujian}
Adapun perangkat lunak dan pustaka yang digunakan pada pengujian ditunjukan pada tabel \ref{tab:test.lib}. Pengujian dilakukan pada perangkat dengan spesifikasi yang ditunjukan pada tabel \ref{tab:test.lib}. 

\begin{table}[!h]
  \centering
  \caption{Lingkungan Pengujian} \label{tab:test.env}
  \begin{tabular}{|p{3cm}|p{6cm}|}
    \hline
    Jenis Lingkungan & Nilai \\ \hline
    Sistem Operasi & Fedora Linux 40 \\ \hline
    Kernel & Linux 6.8.9 \\ \hline
    Manager Paket & Pip 23.3.2 \\ \hline
    CPU & 11th Gen Intel i7-11800H (16) @ 4.600GHz \\ \hline
    RAM & 32GB \\ \hline
  \end{tabular}
\end{table}

Pengujian dilakukan pada sistem operasi linux ditujukan untuk menggunakan fitur dari \emph{UNIX socket} yang telah disediakan oleh kernel linux. Pemilihan \emph{UNIX socket} dilibatkan dalam pengujian ini dikarenakan fitur tersebut dapat mensimulasikan proses TCP tanpa perlu membuka port. Oleh karena itu, fitur ini dapat memudahkan pengujian khususnya bila menggunakan \emph{unit testing}.

\begin{table}[!h]
  \centering
  \caption{Pustaka Pengujian yang Digunakan} \label{tab:test.lib}
  \begin{tabular}{|p{4cm}|p{9cm}|}
    \hline
    Nama Pustaka & Deskripsi \\ \hline
    \texttt{pytest 8.1.1} & Pustaka ini digunakan untuk membantu dalam menyediakan \emph{runtime} pengujian dan membantu dalam proses \emph{debugging} bila terjadi kegagalan saat pengujian berlangsung. \\ \hline
    \texttt{socket} & Pustaka standard ini digunakan untuk melakukan komunikasi melalui \emph{UNIX socket}.\\ \hline
    \texttt{Fast Statictics Test v6.0.1} & Perangkat lunak ini digunakan dalam menguji keteracakan dari bytestream berdasarkan NIST Statistical Test Suite.\\ \hline
    \texttt{Wireshark} & Perangkat lunak ini digunakan dalam mengamati pesan \emph{ciphertext} yang dihasilkan oleh protokol komunikasi.\\ \hline
    \end{tabular}
  \end{table}
    

  Pengujian statistik dilakukan dengan memanfaatkan Fast Statictics Test yang telah diimplementasikan oleh \textcite{marek2016}. Perangkat lunak ini merupakan optimasi dari implementasi pengujian perangkat lunak yang telah dibuat oleh NIST. Oleh karena itu, proses pengujian diharapkan dapat menjadi lebih cepat dan efisien. 

\subsection{Skenario dan Hasil Pengujian}

Bagian ini menjelaskan skenario pengujian yang dilakukan dan hasil dari pengujian yang telah disebutkan sebelumnya. Bagian ini dibagi menjadi dua bagian, yaitu pengujian \emph{cipher} dan pengujian implementasi protokol TLS.

\subsubsection{Pengujian \emph{Cipher}}

Pengujian \emph{cipher} dilakukan dengan dua tahap, yakni pengujian fungsionalitas dan pengujian keamanan. Pengujian fungsionalitas dilakukan dengan beberapa skenario yang ditunjukan pada tabel \emph{test.case.cipher}. Pengujian keamanan dilakukan dengan menggunakan Fast Statictics Test yang telah diimplementasikan oleh \textcite{marek2016}.

\begin{table}[!h]
  \centering
  \caption{Skenario Uji Cipher} \label{tab:test.case.cipher}
  \begin{tabular}{|p{3cm}|p{7cm}|}
    \hline
    Kode Kasus Uji & Deskripsi \\ \hline
    T1.1 & \emph{Cipher} dapat melakukan proses enkripsi pada pesan teks rahasia dengan menggunakan cipher AES-256 kunci blok dinamis\\ \hline
    T1.2 & \emph{Cipher} dapat mendekripsi kembali pesan menggunakan cipher AES-256 kunci blok dinamis\\ \hline
    T1.3 & Hasil dekripsi pada pesan yang dilakukan \emph{replay attack} haruslah gagal\\ \hline
    T1.4 & Hasil dekripsi pada pesan yang mengalami \emph{bit-flip attack} haruslah gagal\\ \hline
    T1.5 & Hasil enkripsi dari \emph{Cipher} pada dua blok yang memiliki pesan yang sama memiliki hasil blok yang berbeda\\ \hline
  \end{tabular}
\end{table}



\section{Analisis Hasil Pengujian} 
\label{sec:analisis-hasil-pengujian}

\subsection{Analisis Data Eksperimen}

\subsection{Ancaman Validitas (Threat of Validity)}
